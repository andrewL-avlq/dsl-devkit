/*
 * generated by Xtext 2.14.0
 */
package com.avaloq.tools.ddk.xtext.format2.formatting2

import com.avaloq.tools.ddk.xtext.format2.format2.FormatConfiguration
import com.avaloq.tools.ddk.xtext.format2.format2.GrammarRule
import com.avaloq.tools.ddk.xtext.format2.services.Format2GrammarAccess
import com.google.inject.Inject
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.xbase.annotations.formatting2.XbaseWithAnnotationsFormatter
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.util.Pair
import org.eclipse.xtext.build.IncrementalBuilder.Result
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import com.avaloq.tools.ddk.xtext.format2.format2.Constant
import com.avaloq.tools.ddk.xtext.format2.format2.WildcardRule
import com.avaloq.tools.ddk.xtext.format2.format2.ContextFreeDirective
import org.eclipse.xtext.formatting2.regionaccess.IComment
import org.eclipse.xtext.formatting2.internal.CommentReplacer
import org.eclipse.xtext.formatting2.internal.WhitespaceReplacer
import org.eclipse.xtext.formatting2.ITextReplacerContext
import org.eclipse.xtext.formatting2.internal.MultilineCommentReplacer
import java.util.ArrayDeque

class Format2Formatter extends XbaseWithAnnotationsFormatter {

  @Inject extension Format2GrammarAccess

  static val LINE_LENGTH = 120;

  override createCommentReplacer(IComment comment) {
    return new CommentReplacer(comment) {
      val CommentReplacer delegate = Format2Formatter.super.createCommentReplacer(comment) as CommentReplacer

      override configureWhitespace(WhitespaceReplacer leading, WhitespaceReplacer trailing) {
        leading.formatting.newLinesMin = 0
        leading.formatting.newLinesDefault = 1
        leading.formatting.newLinesMax = 2
        if (delegate instanceof MultilineCommentReplacer) {
          val min = trailing.formatting.newLineMin
          if (min === null || min < 1)
            trailing.formatting.newLinesMin =1
        }
      }

      override createReplacements(ITextReplacerContext context) {
        return delegate.createReplacements(context)
      }

    }
  }

  def void applyCommonFormatting(EObject element, extension IFormattableDocument document) {
    for (pair : element.regionFor.keywordPairs("{", "}")) {
      pair.key.append[newLine; lowPriority]
      pair.value.append[newLine; lowPriority]
      interior(pair.key, pair.value)[indent; lowPriority]
    }

    for (pair : element.regionFor.keywordPairs("[", "]")) {
      pair.key.append[noSpace; lowPriority]
      pair.value.prepend[noSpace; lowPriority]
    }

    for (keyword : element.regionFor.keywords(";")) {
      keyword.append[newLine; lowPriority]
      keyword.prepend[noSpace; lowPriority]
    }

    for (keyword : element.regionFor.keywords(",")) {
      keyword.prepend[noSpace; lowPriority]
    }

    for (keyword : element.regionFor.keywords("=", "@")) {
      keyword.append[noSpace; lowPriority]
    }
  }

  def dispatch void format(FormatConfiguration formatConfiguration, extension IFormattableDocument document) {
    // TODO: format HiddenRegions around keywords, attributes, cross references, etc.
    formatConfiguration.interior[autowrap(LINE_LENGTH); oneSpace]
    formatConfiguration.regionFor.element(formatConfigurationAccess.group_4).prepend[newLine]
    formatConfiguration.applyCommonFormatting(document)

    val decendants = new ArrayDeque<EObject>()
    decendants.addAll(formatConfiguration.eContents)
    while (!decendants.empty) {
      val decendant = decendants.pop
      decendant.applyCommonFormatting(document)
      decendants.addAll(decendant.eContents)
    }

    var firstConst = true
    for (constant : formatConfiguration.constants) {
      if (firstConst) {
        constant.prepend[setNewLines(2)]
        firstConst = false
      }
      constant.format
    }
    for (rule : formatConfiguration.rules) {
      rule.format
    }
  }

  def dispatch void format(Constant constant, extension IFormattableDocument document) {
    constant.regionFor.keyword(formatConfigurationAccess.constKeyword_5_0).prepend[newLine]
    constant.regionFor.keyword("=").surround[oneSpace]
//    constant.applyCommonFormatting(document);
  }

  def dispatch void format(GrammarRule grammarRule, extension IFormattableDocument document) {
    // TODO: format HiddenRegions around keywords, attributes, cross references, etc.
    grammarRule.prepend[setNewLines(2)]
//    grammarRule.applyCommonFormatting(document);
    for (eObject : grammarRule.directives) {
      eObject.format
    }
  }

  def dispatch void format(WildcardRule wildcardRule, extension IFormattableDocument document) {
    // TODO: format HiddenRegions around keywords, attributes, cross references, etc.
    wildcardRule.prepend[setNewLines(2)]
//    wildcardRule.applyCommonFormatting(document);
    for (eObject : wildcardRule.directives) {
      eObject.format
    }
  }

  def dispatch void format(ContextFreeDirective directive, extension IFormattableDocument document) {
    // TODO: format HiddenRegions around keywords, attributes, cross references, etc.
//    directive.applyCommonFormatting(document);
  }

  // TODO: implement for ContextFreeDirective, SpecificDirective, MatcherList, GroupBlock, KeywordPair, Matcher, SpaceLocator, RightPaddingLocator, LinewrapLocator, ColumnLocator, OffsetLocator, IndentLocator
}
